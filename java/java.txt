// Konsolen Ausgabe
System.out.println("Hello World");

// rechnen
System.out.println(3 * 4);

// main.java Datei notwendig

/*
Multiline Commend
*/

// Variablen

String name = "John";
System.out.println(name);

int myNum = 15;
System.out.println(myNum);

int myNum;
myNum = 15;
System.out.println(myNum);

int myNum = 5;
float myFloatNum = 5.99f;
char myLetter = 'D';
boolean myBool = true;
String myText = "Hello";

String name = "John";
System.out.println("Hello " + name);

String firstName = "John ";
String lastName = "Doe";
String fullName = firstName + lastName;
System.out.println(fullName);

int x = 5;
int y = 6;
System.out.println(x + y); // Print the value of x + y

int x = 5, y = 6, z = 50;
System.out.println(x + y + z);


// Variablen Namen Regeln
Names can contain letters, digits, underscores, and dollar signs
Names must begin with a letter
Names should start with a lowercase letter and it cannot contain whitespace
Names can also begin with $ and _ (but we will not use it in this tutorial)
Names are case sensitive ("myVar" and "myvar" are different variables)
Reserved words (like Java keywords, such as int or boolean) cannot be used as names

// Type Casting

int myInt = 9;
double myDouble = myInt; // Automatic casting: int to double

double myDouble = 9.78d;
int myInt = (int) myDouble; // Manual casting: double to int

// sich selbst addieren
int x = 10;
x += 5;

// logical Operator
&& 	Logical AND	Returns true if both statements are true	x < 5 &&  x < 10	
|| 	Logical OR	Returns true if one of the statements is true	x < 5 || x < 4	
!	Logical NOT	Reverse the result, returns false if the result is true	!(x < 5 && x < 10)


// Vergleich Operator
==	Equal to	x == y	
!=	Not equal	x != y	
>	Greater than	x > y	
<	Less than	x < y	
>=	Greater than or equal to	x >= y	
<=	Less than or equal to	x <= y


// Assignment Operator
=	x = 5	x = 5	
+=	x += 3	x = x + 3	
-=	x -= 3	x = x - 3	
*=	x *= 3	x = x * 3	
/=	x /= 3	x = x / 3	
%=	x %= 3	x = x % 3	
&=	x &= 3	x = x & 3	
|=	x |= 3	x = x | 3	
^=	x ^= 3	x = x ^ 3	
>>=	x >>= 3	x = x >> 3	
<<=	x <<= 3	x = x << 3

// some String Methods

String txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
System.out.println("The length of the txt string is: " + txt.length());

String txt = "Hello World";
System.out.println(txt.toUpperCase());   // Outputs "HELLO WORLD"
System.out.println(txt.toLowerCase());   // Outputs "hello world"

String txt = "Please locate where 'locate' occurs!";
System.out.println(txt.indexOf("locate")); // Outputs 7

String firstName = "John";
String lastName = "Doe";
System.out.println(firstName + " " + lastName);

// Achtung!
String x = "10";
int y = 20;
String z = x + y;  // z will be 1020 (a String)

String txt = "We are the so-called \"Vikings\" from the north."; // Output: We are the so-called "Vikings" from the north.

// Math func

// min / max
Math.max(5, 10);
Math.min(5, 10);

// Wurzel
Math.sqrt(64);

Math.abs(-4.7); // -> wandelt in positiv 4.7

Math.random(); // random zwischen 0 und 1

// boolean

boolean isJavaFun = true;

System.out.println(10 > 9); // returns true, because 10 is higher than 9

// if-else

if (condition1) {
  // block of code to be executed if condition1 is true
} else if (condition2) {
  // block of code to be executed if the condition1 is false and condition2 is true
} else {
  // block of code to be executed if the condition1 is false and condition2 is false
}

// if-else kurz

variable = (condition) ? expressionTrue :  expressionFalse;

// switch

switch(expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}

// while

while (i < 5) {
  System.out.println(i);
  i++;
}

// do-while

do {
  // code block to be executed
}
while (condition);

// for

for (int i = 0; i < 5; i++) {
  System.out.println(i);
}

// for-each

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
for (String i : cars) {
  System.out.println(i);
}

// break -> jumpp out of loop

for (int i = 0; i < 10; i++) {
  if (i == 4) {
    break;
  }
  System.out.println(i);
}

// continue -> skip one iteration

for (int i = 0; i < 10; i++) {
  if (i == 4) {
    continue;
  }
  System.out.println(i);
}

// Arrays

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};

int[] myNum = {10, 20, 30, 40};

// Access element in Array

System.out.println(cars[0]);
// Outputs Volvo

// Change element in Array

cars[0] = "Opel";
// Now outputs Opel instead of Volvo

// get length of array

System.out.println(cars.length);
// Outputs 4

// loop through array

for (int i = 0; i < cars.length; i++) {
  System.out.println(cars[i]);
}

// loop through array for-each

for (type variable : arrayname) {
  ...
}

// multi.dimensional Array

int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };

int x = myNumbers[1][2];
System.out.println(x); // Outputs 7
// erste ziffer bestimmt Array und zweite das element



// Methods

public class Main {
  static void myMethod() {
    // code to be executed
  }
}


// call a Method

public static void main(String[] args) {
    myMethod();
}

// arguments

public class Main {
  static void myMethod(String fname) {
    System.out.println(fname + " Refsnes");
  }

  public static void main(String[] args) {
    myMethod("Liam");
    myMethod("Jenny");
    myMethod("Anja");
  }
}

// multiple parameters

public class Main {
  static void myMethod(String fname, int age) {
    System.out.println(fname + " is " + age);
  }

  public static void main(String[] args) {
    myMethod("Liam", 5);
    myMethod("Jenny", 8);
    myMethod("Anja", 31);
  }
}

// return

static int myMethod(int x) {
    return 5 + x;
}

// store result in a variable

public class Main {
  static int myMethod(int x, int y) {
    return x + y;
  }

  public static void main(String[] args) {
    int z = myMethod(5, 3);
    System.out.println(z);
  }
}
// Outputs 8 (5 + 3)

// Method overloading
multiple methods can have the same name with different parameters

static int plusMethod(int x, int y) {
  return x + y;
}

static double plusMethod(double x, double y) {
  return x + y;
}

public static void main(String[] args) {
  int myNum1 = plusMethod(8, 5);
  double myNum2 = plusMethod(4.3, 6.26);
  System.out.println("int: " + myNum1);
  System.out.println("double: " + myNum2);
}


// scope

// method scope

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    int x = 100;

    // Code here can use x
    System.out.println(x);
  }
}

// block scope

public class Main {
  public static void main(String[] args) {

    // Code here CANNOT use x

    { // This is a block

      // Code here CANNOT use x

      int x = 100;

      // Code here CAN use x
      System.out.println(x);

   } // The block ends here

  // Code here CANNOT use x

  }
}

public class Main {
  public static void main(String[] args) {
    int result = sum(10);
    System.out.println(result);
  }
  public static int sum(int k) {
    if (k > 0) {
      return k + sum(k - 1);
    } else {
      return 0;
    }
  }
}
// output: 55


// classes and objects

public class Main {
  int x = 5;

  public static void main(String[] args) {
    Main myObj = new Main();
    System.out.println(myObj.x);
  }
}

public class Main {
  int x = 5; // Attribute

  public static void main(String[] args) {
    Main myObj1 = new Main();  // Object 1
    Main myObj2 = new Main();  // Object 2
    System.out.println(myObj1.x);
    System.out.println(myObj2.x);
  }
}
 
// multiple classes

// Main.java
public class Main {
  int x = 5;
}

// Second.java
class Second {
  public static void main(String[] args) {
    Main myObj = new Main();
    System.out.println(myObj.x);
  }
}

// modify Attribute

public class Main {
  int x; // überschreibbar
  final int y = 10; // nicht überschreibbar

  public static void main(String[] args) {
    Main myObj = new Main();
    myObj.x = 40; // hier
    System.out.println(myObj.x);
  }
}


// public vs static

public class Main {
  // Static method
  static void myStaticMethod() {
    System.out.println("Static methods can be called without creating objects");
  }

  // Public method
  public void myPublicMethod() {
    System.out.println("Public methods must be called by creating objects");
  }

  // Main method
  public static void main(String[] args) {
    myStaticMethod(); // Call the static method
    // myPublicMethod(); This would compile an error

    Main myObj = new Main(); // Create an object of Main
    myObj.myPublicMethod(); // Call the public method on the object
  }
}

// access methods with objects

public class Main {
 
  // fullThrottle() method
  public void fullThrottle() {
    System.out.println("The car is going as fast as it can!");
  }

  // speed() method and add a parameter
  public void speed(int maxSpeed) {
    System.out.println("Max speed is: " + maxSpeed);
  }

  // Inside main, call the methods on the myCar object
  public static void main(String[] args) {
    Main myCar = new Main();   // Create a myCar object
    myCar.fullThrottle();      // Call the fullThrottle() method
    myCar.speed(200);          // Call the speed() method
  }
}

// The car is going as fast as it can!
// Max speed is: 200


// Constructors

public class Main {
  int x;  // class attribute

  // Create a class constructor for the Main class
  public Main() {
    x = 5;  // Set the initial value for the class attribute x
  }

  public static void main(String[] args) {
    Main myObj = new Main(); // Create an object of class Main (This will call the constructor)
    System.out.println(myObj.x); // Print the value of x
  }
}
// Outputs 5

// Constructor parameters

public class Main {
  int x;

  public Main(int y) {
    x = y;
  }

  public static void main(String[] args) {
    Main myObj = new Main(5);
    System.out.println(myObj.x);
  }
}
// Outputs 5


public class Main {
  int modelYear;
  String modelName;

  public Main(int year, String name) {
    modelYear = year;
    modelName = name;
  }

  public static void main(String[] args) {
    Main myCar = new Main(1969, "Mustang");
    System.out.println(myCar.modelYear + " " + myCar.modelName);
  }
}

// Outputs 1969 Mustang


// Modifiers

// Access Modifiers

public	The code is accessible for all classes

private	The code is only accessible within the declared class

default	The code is only accessible in the same package.
This is used when you don't specify a modifier.

protected	The code is accessible in the same package and subclasses.


// non-access Modifiers

final	Attributes and methods cannot be overridden/modified

static	Attributes and methods belongs to the class, rather than an object

abstract	Can only be used in an abstract class, and can only be used on methods. The method does not have a body, for example abstract void run();. The body is provided by the subclass (inherited from). You will learn more about inheritance and abstraction in the Inheritance and Abstraction chapters

transient	Attributes and methods are skipped when serializing the object containing them

synchronized	Methods can only be accessed by one thread at a time

volatile	The value of an attribute is not cached thread-locally, and is always read from the "main memory"


// Code from filename: Main.java
// abstract class
abstract class Main {
  public String fname = "John";
  public int age = 24;
  public abstract void study(); // abstract method
}

// Subclass (inherit from Main)
class Student extends Main {
  public int graduationYear = 2018;
  public void study() { // the body of the abstract method is provided here
    System.out.println("Studying all day long");
  }
}
// End code from filename: Main.java

// Code from filename: Second.java
class Second {
  public static void main(String[] args) {
    // create an object of the Student class (which inherits attributes and methods from Main)
    Student myObj = new Student();

    System.out.println("Name: " + myObj.fname);
    System.out.println("Age: " + myObj.age);
    System.out.println("Graduation Year: " + myObj.graduationYear);
    myObj.study(); // call abstract method
  }
}


// Encapsulation -> hide sensitive data from users

public class Person {
  private String name; // private = restricted access

  // Getter
  public String getName() {
    return name;
  }

  // Setter
  public void setName(String newName) {
    this.name = newName;
  }
}

// built-in packages

import package.name.Class;   // Import a single class
import package.name.*;   // Import the whole package

// get user-input

import java.util.Scanner;

class MyClass {
  public static void main(String[] args) {
    Scanner myObj = new Scanner(System.in);
    System.out.println("Enter username");

    String userName = myObj.nextLine();
    System.out.println("Username is: " + userName);
  }
}

// create own package

package mypack;
class MyPackageClass {
  public static void main(String[] args) {
    System.out.println("This is my package!");
  }
}


// Inheritance -> extend keyword

class Vehicle {
  protected String brand = "Ford";        // Vehicle attribute
  public void honk() {                    // Vehicle method
    System.out.println("Tuut, tuut!");
  }
}

class Car extends Vehicle {
  private String modelName = "Mustang";    // Car attribute
  public static void main(String[] args) {

    // Create a myCar object
    Car myCar = new Car();

    // Call the honk() method (from the Vehicle class) on the myCar object
    myCar.honk();

    // Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class
    System.out.println(myCar.brand + " " + myCar.modelName);
  }
}


// Polymorphism

class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}

class Main {
  public static void main(String[] args) {
    Animal myAnimal = new Animal();  // Create a Animal object
    Animal myPig = new Pig();  // Create a Pig object
    Animal myDog = new Dog();  // Create a Dog object
    myAnimal.animalSound();
    myPig.animalSound();
    myDog.animalSound();
  }
}


// inner classes

class OuterClass {
  int x = 10;

  class InnerClass {
    int y = 5;
  }
}

public class Main {
  public static void main(String[] args) {
    OuterClass myOuter = new OuterClass();
    OuterClass.InnerClass myInner = myOuter.new InnerClass();
    System.out.println(myInner.y + myOuter.x);
  }
}
// Outputs 15 (5 + 10)

// access outer class from inner class
class OuterClass {
  int x = 10;

  class InnerClass {
    public int myInnerMethod() {
      return x;
    }
  }
}

public class Main {
  public static void main(String[] args) {
    OuterClass myOuter = new OuterClass();
    OuterClass.InnerClass myInner = myOuter.new InnerClass();
    System.out.println(myInner.myInnerMethod());
  }
}

// Outputs 10


// abstraction -> process of hiding certain details and showing only essential information to the user

Abstract class: is a restricted class that cannot be used to create objects
(to access it, it must be inherited from another class)

Abstract method: can only be used in an abstract class, and it does not have a body.
The body is provided by the subclass (inherited from)

// Abstract class
abstract class Animal {
  // Abstract method (does not have a body)
  public abstract void animalSound();
  // Regular method
  public void sleep() {
    System.out.println("Zzz");
  }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig(); // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}

// Interfaces -> a completely "abstract class" that is used to group related methods with empty bodies

// interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void run(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}

// multiple Interfaces

class DemoClass implements FirstInterface, SecondInterface {
  public void myMethod() {
    System.out.println("Some text..");
  }
  public void myOtherMethod() {
    System.out.println("Some other text...");
  }
}


// enums -> special "class" that represents a group of constants (unchangeable variables, like final variables)

// create
enum Level {
  LOW,
  MEDIUM,
  HIGH
}

// access
Level myVar = Level.MEDIUM;

// enum in switch

enum Level {
  LOW,
  MEDIUM,
  HIGH
}

public class Main {
  public static void main(String[] args) {
    Level myVar = Level.MEDIUM;

    switch(myVar) {
      case LOW:
        System.out.println("Low level");
        break;
      case MEDIUM:
         System.out.println("Medium level");
        break;
      case HIGH:
        System.out.println("High level");
        break;
    }
  }
}

// loop through

for (Level myVar : Level.values()) {
  System.out.println(myVar);
}

// User input

import java.util.Scanner;

class Main {
  public static void main(String[] args) {
    Scanner myObj = new Scanner(System.in);

    System.out.println("Enter name, age and salary:");

    // String input
    String name = myObj.nextLine();

    // Numerical input
    int age = myObj.nextInt();
    double salary = myObj.nextDouble();

    // Output input by user
    System.out.println("Name: " + name);
    System.out.println("Age: " + age);
    System.out.println("Salary: " + salary);
  }
}

// time and Date

import java.time.LocalDate; // import the LocalDate class

public class Main {
  public static void main(String[] args) {
    LocalDate myObj = LocalDate.now(); // Create a date object
    System.out.println(myObj); // Display the current date
  }
}
// output 2022-11-01

import java.time.LocalTime; // import the LocalTime class

public class Main {
  public static void main(String[] args) {
    LocalTime myObj = LocalTime.now();
    System.out.println(myObj);
  }
}
// output 11:09:38.319683


// both

import java.time.LocalDateTime; // import the LocalDateTime class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myObj = LocalDateTime.now();
    System.out.println(myObj);
  }
}
// output 2022-11-01T11:09:38.319253

// formatiert

import java.time.LocalDateTime; // Import the LocalDateTime class
import java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myDateObj = LocalDateTime.now();
    System.out.println("Before formatting: " + myDateObj);
    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

    String formattedDate = myDateObj.format(myFormatObj);
    System.out.println("After formatting: " + formattedDate);
  }
}
// output
Before Formatting: 2022-11-01T11:09:38.319319
After Formatting: 01-11-2022 11:09:38


// ArrayList -> class is a resizable array, which can be found in the java.util package
    + elements can be added and removed from an ArrayList

import java.util.ArrayList; // import the ArrayList class

ArrayList<String> cars = new ArrayList<String>(); // Create an ArrayList object

// add
cars.add("Volvo");

// access
cars.get(0);

// Change
cars.set(0, "Opel");

// remove
cars.remove(0);

// remove all
cars.clear();

// how many elements
cars.size();

// loop through ArrayList
for (int i = 0; i < cars.size(); i++) {
    System.out.println(cars.get(i));
}

// for each
for (String i : cars) {
    System.out.println(i);
}

// sort
Collections.sort(cars);
for (String i : cars) {
    System.out.println(i);
}


// LinkedList -> ArrayList for storing and accessing data, and LinkedList to manipulate data
LinkedList<String> cars = new LinkedList<String>();


// Hash-map -> store items in "key/value" pairs, and you can access them by an index of another type

import java.util.HashMap; // import the HashMap class

HashMap<String, String> capitalCities = new HashMap<String, String>();

// Add keys and values (Country, City)
capitalCities.put("England", "London");

// access
capitalCities.get("England");

// remove
capitalCities.remove("England");

// remove all
capitalCities.clear();

// size
capitalCities.size();

// loop through
for (String i : capitalCities.keySet()) {
    System.out.println(i);
}
